package com.math.sort;

public class Sort {

	/*
	 * ================================================ 功能：选择排序
	 * 输入：数组名称（也就是数组首地址）、数组中元素个数
	 * ================================================
	 */
	/*
	 * ==================================================== 算法思想简单描述：
	 * 
	 * 在要排序的一组数中，选出最小的一个数与第一个位置的数交换； 然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环
	 * 到倒数第二个数和最后一个数比较为止。
	 * 
	 * 选择排序是不稳定的。算法复杂度O(n2)--[n的平方]
	 * =====================================================
	 */
	void select_sort(int[] x, int n) {
		int i, j, min, t;

		for (i = 0; i < n - 1; i++) /* 要选择的次数：0~n-2共n-1次 */
		{
			min = i; /* 假设当前下标为i的数最小，比较后再调整 */
			for (j = i + 1; j < n; j++)/* 循环找出最小的数的下标是哪个 */
			{
				if (x[j] < x[min]) {
					min = j; /* 如果后面的数比前面的小，则记下它的下标 */
				}
			}

			if (min != i) /* 如果min在循环中改变了，就需要交换数据 */
			{
				t = x[i];
				x[i] = x[min];
				x[min] = t;
			}
		}
	}

	/*
	 * ================================================ 功能：直接插入排序
	 * 输入：数组名称（也就是数组首地址）、数组中元素个数
	 * ================================================
	 */
	/*
	 * ==================================================== 算法思想简单描述：
	 * 
	 * 在要排序的一组数中，假设前面(n-1) [n>=2] 个数已经是排 好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数
	 * 也是排好顺序的。如此反复循环，直到全部排好顺序。
	 * 
	 * 直接插入排序是稳定的。算法时间复杂度O(n2)--[n的平方]
	 * =====================================================
	 */
	void insert_sort(int[] x, int n) {
		int i, j, t;

		for (i = 1; i < n; i++) /* 要选择的次数：1~n-1共n-1次 */
		{
			/*
			 * 暂存下标为i的数。注意：下标从1开始，原因就是开始时 第一个数即下标为0的数，前面没有任何数，单单一个，认为 它是排好顺序的。
			 */
			t = x[i];
			for (j = i - 1; j >= 0 && t < x[j]; j--) /*
													 * 注意：j=i-1，j--，这里就是下标为i的数，
													 * 在它前面有序列中找插入位置。
													 */
			{
				x[j + 1] = x[j]; /*
								 * 如果满足条件就往后挪。最坏的情况就是t比下标为0的数都小，它要放在最前面，j==-1，退出循环
								 */
			}

			x[j + 1] = t; /* 找到下标为i的数的放置位置 */
		}
	}

	/*
	 * ================================================ 功能：冒泡排序
	 * 输入：数组名称（也就是数组首地址）、数组中元素个数
	 * ================================================
	 */
	/*
	 * ==================================================== 算法思想简单描述：
	 * 
	 * 在要排序的一组数中，对当前还未排好序的范围内的全部数，自上 而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较
	 * 小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要 求相反时，就将它们互换。
	 * 
	 * 下面是一种改进的冒泡算法，它记录了每一遍扫描后最后下沉数的 位置k，这样可以减少外层循环扫描的次数。
	 * 
	 * 冒泡排序是稳定的。算法时间复杂度O(n2)--[n的平方]
	 * =====================================================
	 */

	void bubble_sort(int[] x, int n) {
		int j, k, h, t;

		for (h = n - 1; h > 0; h = k) /* 循环到没有比较范围 */
		{
			for (j = 0, k = 0; j < h; j++) /* 每次预置k=0，循环扫描后更新k */
			{
				if (x[j] > x[j + 1]) /* 大的放在后面，小的放到前面 */
				{
					t = x[j];
					x[j] = x[j + 1];
					x[j + 1] = t; /* 完成交换 */
					k = j; /* 保存最后下沉的位置。这样k后面的都是排序排好了的。 */
				}
			}
		}
	}

	void bubble_sort_wjx(int[] x, int n) {
		int j, h, t;
		boolean sortting = true;

		for (h = n - 2; sortting && h > 0; h++) /* 循环到没有比较范围 */
		{
			for (j = 0, sortting = false; j < h; j++) /* 每次预置k=0，循环扫描后更新k */
			{
				if (x[j] > x[j + 1]) /* 大的放在后面，小的放到前面 */
				{
					t = x[j];
					x[j] = x[j + 1];
					x[j + 1] = t; /* 完成交换 */
					sortting = true; /* 有效换，正在排序，也就是美欧完成。 */
				}
			}
		}
	}

	/*
	 * ================================================ 功能：希尔排序
	 * 输入：数组名称（也就是数组首地址）、数组中元素个数
	 * ================================================
	 */
	/*
	 * ==================================================== 算法思想简单描述：
	 * 
	 * 在直接插入排序算法中，每次插入一个数，使有序序列只增加1个节点， 并且对插入下一个数没有提供任何帮助。如果比较相隔较远距离（称为
	 * 增量）的数，使得数移动时能跨过多个元素，则进行一次比较就可能消除 多个元素交换。D.L.shell于1959年在以他名字命名的排序算法中实现
	 * 了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中 记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量
	 * 对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成 一组，排序完成。
	 * 
	 * 下面的函数是一个希尔排序算法的一个实现，初次取序列的一半为增量， 以后每次减半，直到增量为1。
	 * 
	 * 希尔排序是不稳定的。 =====================================================
	 */
	void shell_sort(int[] x, int n) {
		int h, j, k, t;

		for (h = n / 2; h > 0; h = h / 2) /* 控制增量 */
		{
			for (j = h; j < n; j++) /* 这个实际上就是上面的直接插入排序 */
			{
				t = x[j];
				for (k = j - h; (k >= 0 && t < x[k]); k -= h) {
					x[k + h] = x[k];
				}
				x[k + h] = t;
			}
		}
	}

}
